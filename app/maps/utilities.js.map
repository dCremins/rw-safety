{"version":3,"sources":["slider.js","flaggerMove.js","flaggerClick.js","flaggerRelease.js","flagger.js","sign.js","input.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../utilities.js","sourcesContent":["var showing = 'none'\n\nfunction slide(id) {\n  switch(showing) {\n    case id:\n      document.getElementById(id).removeAttribute(\"style\")\n      document.getElementsByClassName(id)[0].removeAttribute(\"style\")\n      break\n    case 'group-1':\n      document.getElementById('group-1').removeAttribute(\"style\")\n      document.getElementsByClassName('group-1')[0].removeAttribute(\"style\")\n      break\n    case 'group-2':\n      document.getElementById('group-2').removeAttribute(\"style\")\n      document.getElementsByClassName('group-2')[0].removeAttribute(\"style\")\n      break\n    case 'group-3':\n      document.getElementById('group-3').removeAttribute(\"style\")\n      document.getElementsByClassName('group-3')[0].removeAttribute(\"style\")\n      break\n    case 'group-4':\n      document.getElementById('group-4').removeAttribute(\"style\")\n      document.getElementsByClassName('group-4')[0].removeAttribute(\"style\")\n      break\n    case 'group-5':\n      document.getElementById('group-5').removeAttribute(\"style\")\n      document.getElementsByClassName('group-5')[0].removeAttribute(\"style\")\n      break\n    case 'group-6':\n      document.getElementById('group-6').removeAttribute(\"style\")\n      document.getElementsByClassName('group-6')[0].removeAttribute(\"style\")\n      break\n    default:\n      break\n  }\n  if (showing !== id) {\n    document.getElementsByClassName(id)[0].style.backgroundColor = \"#666\"\n    document.getElementById(id).style.width = \"300px\"\n    showing = id\n  } else {\n    showing = 'none'\n  }\n}\n","function onDocumentMouseMove( event ) {\n\tevent.preventDefault()\n\tvar rect = renderer.domElement.getBoundingClientRect()\n\tmouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1\n\tmouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1\n\traycaster.setFromCamera( mouse, camera )\n\tif ( selected ) {\n\t\t\tif ( raycaster.intersectObjects( objects ) ) {\n\t\t\t\tselected.position.set(0, 1, 0)\n\t\t\t\tselected.position.set( raycaster.intersectObjects( objects )[0].point.x, selected.position.y, raycaster.intersectObjects( objects )[0].point.z );\n\t\t\t}\n\t\t}\n\t\traycaster.setFromCamera( mouse, camera );\n\t\tvar intersects = raycaster.intersectObjects( flaggers );\n\t\tif ( intersects.length > 0 ) {\n\t\t\tvar object = intersects[ 0 ].object;\n\t\t\tif ( hovered !== object ) {\n\t\t\t\trenderer.domElement.style.cursor = 'pointer';\n\t\t\t\thovered = object;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( hovered !== null ) {\n\t\t\t\trenderer.domElement.style.cursor = 'auto';\n\t\t\t\thovered = null;\n\t\t\t}\n\t\t}\n}\n\nfunction onDocumentTouchMove( event ) {\n\tevent.preventDefault()\n  event = event.changedTouches[ 0 ]\n\tvar rect = renderer.domElement.getBoundingClientRect()\n\tmouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1\n\tmouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1\n\traycaster.setFromCamera( mouse, camera )\n\tif ( selected ) {\n\t\tif ( raycaster.intersectObjects( objects ) ) {\n\t\t\tselected.position.set(0, 1, 0)\n\t\t\tselected.position.set( raycaster.intersectObjects( objects )[0].point.x, selected.position.y, raycaster.intersectObjects( objects )[0].point.z );\n\t\t}\n\t}\n}\n","function onDocumentMouseDown( event ) {\n\tcontrols.enabled = false\n\tevent.preventDefault();\n\traycaster.setFromCamera( mouse, camera );\n\tvar intersects = raycaster.intersectObjects( flaggers );\n\tif ( intersects.length > 0 ) {\n\t\tselected = intersects[ 0 ].object;\n\t\tif ( raycaster.intersectObjects( objects ) ) {\n\t\t\toffset.copy( intersection ).sub( selected.position );\n\t\t}\n\t\trenderer.domElement.style.cursor = 'move';\n\t}\n}\n\nfunction onDocumentTouchStart( event ) {\n\tcontrols.enabled = false\n\tevent.preventDefault()\n  event = event.changedTouches[ 0 ]\n\tvar rect = renderer.domElement.getBoundingClientRect()\n\tmouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1\n\tmouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1\n\traycaster.setFromCamera( mouse, camera );\n\tvar intersects = raycaster.intersectObjects( flaggers )\n\tif ( intersects.length > 0 ) {\n\t\tselected = intersects[ 0 ].object;\n\t\tif ( raycaster.intersectObjects( objects ) ) {\n\t\t\toffset.copy( intersection ).sub( selected.position );\n\t\t}\n\t\trenderer.domElement.style.cursor = 'move';\n\t}\n}\n","function onDocumentMouseCancel( event ) {\n\tcontrols.enabled = true\n\tevent.preventDefault();\n\tif ( selected ) {\n\t\tselected = null;\n\t}\n\trenderer.domElement.style.cursor = 'auto';\n}\n\nfunction onDocumentTouchEnd( event ) {\n  controls.enabled = true\n  event.preventDefault();\n  if ( selected ) {\n    selected = null;\n  }\n  renderer.domElement.style.cursor = 'auto';\n}\n","\n\nfunction flagger(color) {\n\tvar body = new THREE.Geometry()\n\t\t// Torso\n  \tvar torso = new THREE.BoxGeometry( 1, 1.4, .8 )\n\t\ttorso.translate(0, .1, 0)\n\t\ttorso.vertices[0].z-=.15;\n\t\ttorso.vertices[0].x-=.15;\n\t\ttorso.vertices[1].z+=.15;\n\t\ttorso.vertices[1].x-=.15;\n\t\ttorso.vertices[4].z+=.15;\n\t\ttorso.vertices[4].x+=.15;\n\t\ttorso.vertices[5].z-=.15;\n\t\ttorso.vertices[5].x+=.15;\n\t\tbody.merge(torso)\n\t\t// Legs\n  \tvar leftLeg = new THREE.BoxGeometry( .5, .8, .8 )\n\t\tleftLeg.translate(-.25, -1, 0)\n\t\tleftLeg.vertices[0].x-=.1;\n\t\tleftLeg.vertices[1].x-=.1;\n\t\tleftLeg.vertices[2].x-=.3;\n\t\tleftLeg.vertices[2].z-=.3;\n\t\tleftLeg.vertices[3].x-=.3;\n\t\tleftLeg.vertices[3].z+=.3;\n\t\tleftLeg.vertices[6].z+=.3;\n\t\tleftLeg.vertices[7].z-=.3;\n\t\tbody.merge(leftLeg)\n  \tvar rightLeg = new THREE.BoxGeometry( .5, .8, .8 )\n\t\trightLeg.translate(.25, -1, 0)\n\t\trightLeg.vertices[4].x+=.1;\n\t\trightLeg.vertices[5].x+=.1;\n\t\trightLeg.vertices[2].z-=.3;\n\t\trightLeg.vertices[3].z+=.3;\n\t\trightLeg.vertices[6].x+=.3;\n\t\trightLeg.vertices[6].z+=.3;\n\t\trightLeg.vertices[7].x+=.3;\n\t\trightLeg.vertices[7].z-=.3;\n\t\tbody.merge(rightLeg)\n\t\t// Arms\n  \tvar rightArm1 = new THREE.BoxGeometry( .5, .4, .5 )\n\t\trightArm1.translate(.64, .6, 0)\n\t\trightArm1.vertices[0].y -= .1;\n\t\trightArm1.vertices[0].z += .1;\n\t\trightArm1.vertices[0].x -= .2;\n\n\t\trightArm1.vertices[1].y -= .08;\n\t\trightArm1.vertices[1].z += .3;\n\t\trightArm1.vertices[1].x -= .1;\n\n\t\trightArm1.vertices[2].z += .1;\n\t\trightArm1.vertices[2].x -= .05;\n\t\trightArm1.vertices[2].y += .1;\n\n\t\trightArm1.vertices[3].y += .2;\n\t\trightArm1.vertices[3].z += .4;\n\t\trightArm1.vertices[3].x += .2;\n\n\t\trightArm1.vertices[4].x -= .04;\n\t\trightArm1.vertices[5].x -= .04;\n\t\tbody.merge(rightArm1)\n  \tvar rightArm2 = new THREE.BoxGeometry( .5, .3, .3 )\n\t\trightArm2.translate(1.14, .6, .3)\n\t\trightArm2.vertices[0].y+=.25;\n\t\trightArm2.vertices[0].z-=.1;\n\t\trightArm2.vertices[0].x-=.65;\n\n\t\trightArm2.vertices[1].y+=.25;\n\t\trightArm2.vertices[1].z+=.05;\n\t\trightArm2.vertices[1].x-=.5;\n\n\t\trightArm2.vertices[2].y+=.55;\n\t\trightArm2.vertices[2].z-=.05;\n\t\trightArm2.vertices[2].x-=.55;\n\n\t\trightArm2.vertices[3].y+=.55;\n\t\trightArm2.vertices[3].z+=.1;\n\t\trightArm2.vertices[3].x-=.4;\n\n\t\trightArm2.vertices[4].x-=.1;\n\t\trightArm2.vertices[4].z-=.1;\n\t\trightArm2.vertices[4].y-=.03;\n\n\t\trightArm2.vertices[5].y-=.05;\n\t\trightArm2.vertices[5].z-=.1;\n\t\trightArm2.vertices[5].x-=.2;\n\n\t\trightArm2.vertices[6].x+=.2;\n\t\trightArm2.vertices[6].y+=.15;\n\t\trightArm2.vertices[6].z+=.0;\n\n\t\trightArm2.vertices[7].x-=.05;\n\t\trightArm2.vertices[7].z-=.1;\n\t\trightArm2.vertices[7].y+=.05;\n\t\tbody.merge(rightArm2)\n  \tvar leftArm = new THREE.BoxGeometry( 1, .4, .5 )\n\t\tleftArm.translate(-.85, .6, 0)\n\t\tleftArm.vertices[5].y-=.8;\n\t\tleftArm.vertices[5].z-=.1;\n\t\tleftArm.vertices[4].y-=.8;\n\t\tleftArm.vertices[4].z+=.1;\n\t\tleftArm.vertices[7].y-=.5;\n\t\tleftArm.vertices[7].z-=.1;\n\t\tleftArm.vertices[6].y-=.5;\n\t\tleftArm.vertices[6].z+=.1;\n\t\tleftArm.vertices[3].x-=.04;\n\t\tleftArm.vertices[2].x-=.04;\n\t\tbody.merge(leftArm)\n\t\t// Head\n  \tvar head = new THREE.SphereGeometry( .35, 32, 32 )\n\t\thead.translate(0, 1.3, 0)\n\t\tbody.merge(head)\n\t\t// Flag\n\t\tvar object = new THREE.Geometry();\n\t\tobject.vertices.push( new THREE.Vector3( 0, .15, 0))\n\t\t  for (var i = 0; i <= 7; i++) {\n\t\t    var angle = (i * 2 * Math.PI / 8)\n\t\t    object.vertices.push( new THREE.Vector3( .6 * Math.sin(angle),  .15, .6 * Math.cos(angle)))\n\t\t  }\n\t\t\tobject.vertices.push( new THREE.Vector3( 0, 0, 0))\n\t\t  for (var i = 7; i >= 0; i--) {\n\t\t    var angle = (i * 2 * Math.PI / 8)\n\t\t    object.vertices.push( new THREE.Vector3(.6 * Math.sin(angle) , 0, .6 * Math.cos(angle)))\n\t\t  }\n\t\t  object.faces.push( new THREE.Face3( 0, 1, 2) )\n\t\t  object.faces.push( new THREE.Face3( 0, 2, 3) )\n\t\t  object.faces.push( new THREE.Face3( 0, 3, 4) )\n\t\t  object.faces.push( new THREE.Face3( 0, 4, 5) )\n\t\t  object.faces.push( new THREE.Face3( 0, 5, 6) )\n\t\t  object.faces.push( new THREE.Face3( 0, 6, 7) )\n\t\t  object.faces.push( new THREE.Face3( 0, 7, 8) )\n\t\t  object.faces.push( new THREE.Face3( 0, 8, 1) )\n\t\t  object.faces.push( new THREE.Face3( 9, 10, 11) )\n\t\t  object.faces.push( new THREE.Face3( 9, 11, 12) )\n\t\t  object.faces.push( new THREE.Face3( 9, 12, 13) )\n\t\t  object.faces.push( new THREE.Face3( 9, 13, 14) )\n\t\t  object.faces.push( new THREE.Face3( 9, 14, 15) )\n\t\t  object.faces.push( new THREE.Face3( 9, 15, 16) )\n\t\t  object.faces.push( new THREE.Face3( 9, 16, 17) )\n\t\t  object.faces.push( new THREE.Face3( 9, 17, 10) )\n\t\t  object.faces.push( new THREE.Face3( 5, 4, 14 ) )\n\t\t  object.faces.push( new THREE.Face3( 14, 13, 5 ) )\n\t\t  object.faces.push( new THREE.Face3( 4, 3, 15 ) )\n\t\t  object.faces.push( new THREE.Face3( 15, 14, 4 ) )\n\t\t  object.faces.push( new THREE.Face3( 3, 2, 16 ) )\n\t\t  object.faces.push( new THREE.Face3( 16, 15, 3 ) )\n\t\t  object.faces.push( new THREE.Face3( 2, 1, 17 ) )\n\t\t  object.faces.push( new THREE.Face3( 17, 16, 2 ) )\n\t\t  object.faces.push( new THREE.Face3( 1, 8, 10 ) )\n\t\t  object.faces.push( new THREE.Face3( 10, 17, 1 ) )\n\t\t  object.faces.push( new THREE.Face3( 8, 7, 11 ) )\n\t\t  object.faces.push( new THREE.Face3( 11, 10, 8 ) )\n\t\t  object.faces.push( new THREE.Face3( 7, 6, 12 ) )\n\t\t  object.faces.push( new THREE.Face3( 12, 11, 7 ) )\n\t\t  object.faces.push( new THREE.Face3( 6, 5, 13 ) )\n\t\t  object.faces.push( new THREE.Face3( 13, 12, 6 ) )\n\t\t  object.computeFaceNormals();\n\t\t\tsign = new THREE.Mesh( object, safetyOrange )\n\t\t\tsign.position.set(-.68, .9, .02)\n\t\t\tsign.rotation.x += .4\n\t\t\tsign.rotation.y += .6\n\t\t\tsign.rotation.z += 1.35\n\t\t\tsign.geometry.scale(.5, .5, .5)\n\t\t\tscene.add(sign)\n\t  \tvar stickG = new THREE.CylinderGeometry( .05, .05, 2.4, 32 )\n\t\t\tstick = new THREE.Mesh( stickG, gray )\n\t\t\tstick.position.set(-.7, .05, .02)\n\t\t\tstick.geometry.scale(.5, .5, .5)\n\t\t\tscene.add(stick)\n\n    \tvar person = new THREE.Mesh( body, color )\n    \tperson.position.set(0, 1.2, -1)\n    \tperson.rotation.y -= 1\n    \tperson.geometry.scale(.5, .5, .5)\n    \tperson.add(sign)\n    \tperson.add(stick)\n\n\t\t\tvar shadowPersonGeometry = new THREE.Geometry()\n\t\t\tshadowPersonClone = body.clone()\n\t\t\tshadowPersonGeometry.merge(shadowPersonClone)\n\t\t\tstickClone = stickG.clone()\n\t\t\tstickClone.translate(-.7, .05, .02)\n\t\t\tshadowPersonGeometry.merge(stickClone)\n    \tvar shadowPerson = new THREE.Mesh( shadowPersonGeometry, shadows )\n    \t//shadowPerson.position.set(0, 1.2, -1)\n    \t//shadowPerson.rotation.y -= 1\n\t\t\tshadowPerson.receiveShadow = true\n\t\t\tsignClone = new THREE.Mesh( object, shadows )\n\t\t\tsignClone.position.set(-.68, .9, .02)\n\t\t\tsignClone.rotation.x += .4\n\t\t\tsignClone.rotation.y += .6\n\t\t\tsignClone.rotation.z += 1.35\n\t\t\tshadowPerson.add(signClone)\n\t\t\tperson.add(shadowPerson)\n\n\n\tscene.add(person)\n  flaggers.push(person)\n\n  var person2 = person.clone(true)\n  person2.position.set(1, 1.2, -1)\n  scene.add(person2)\n  flaggers.push(person2)\n}\n","var signs = [[], [], [], [], [], [], []]\n\nfunction signArray(group, checkbox) {\n  var idx = signs[group].indexOf(checkbox.value);\n\n    if (idx !== -1) {         // if already in array\n    \tsigns[group].splice(idx, 1); // make sure we remove it\n    }\n\n    if (checkbox.checked) {    // if checked\n    \tsigns[group].unshift(checkbox.value);  // add to end of array\n    }\n}\n\nfunction signSpace(color, group, start) {\n    var signGrouped = new THREE.Group()\n    var spacing = Number(document.getElementById('sign-'+group).value)/200\n\n    // Get Signs\n\n    var signImages = signs[group]\n    var pos = start-spacing\n    for (var i = 0; i < signImages.length && pos >= -22; i++) {\n      // Image\n\n    \tvar signBase = new THREE.CylinderGeometry(.8, .8, .1, 4)\n    \tsignBase.rotateX(1.5)\n    \tsignBase.rotateZ(1.6)\n\n      switch (signImages[i]) {\n        case 'worker':\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, workerSignMaterial, safetyOrange])\n          break\n        case 'flagger':\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, flaggerSignMaterial, safetyOrange])\n          break\n        case 'fAhead':\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, flagAheadSignMaterial, safetyOrange])\n          break\n        case 'men':\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, menWorkSignMaterial, safetyOrange])\n          break\n        case 'stop':\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, prepareStopSignMaterial, safetyOrange])\n          break\n        case 'lane':\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, oneLaneSignMaterial, safetyOrange])\n          break\n        default:\n          var sign1 = new THREE.Mesh(signBase, [safetyOrange, workAheadSignMaterial, safetyOrange])\n          break\n      }\n\n    \tsign1.position.set(pos, 3, (4+(group*.5)))\n    \tsignGrouped.add(sign1)\n\n      // Group Color Backing\n\n    \tvar signColor = new THREE.CylinderGeometry(1, 1, .1, 4)\n    \tsignColor.rotateX(1.5)\n    \tsignColor.rotateZ(1.6)\n    \tvar signColorBack = new THREE.Mesh(signColor, color)\n    \tsignColorBack.position.set((pos+.01), 3, (4+(group*.5)))\n    \tsignGrouped.add(signColorBack)\n\n      // Stick\n\n      var stick = new THREE.CylinderGeometry(.05, .05, 2, 32)\n    \tvar signStick = new THREE.Mesh(stick, color)\n    \tsignStick.position.set((pos+.01), 1.2, (4+(group*.5)))\n    \tsignGrouped.add(signStick)\nconsole.log((4+(group/.5)))\n      // Position and Add to Scene\n      pos -= 2\n    }\n\n    signGrouped.name = 'signGroup-'+group\n    scene.add(signGrouped)\n}\n","function test(group, color) {\n  // Remove old render if it exists\n  if (scene.getObjectByName(group)) {\n    scene.remove(scene.getObjectByName(group))\n  }\n\n  if (scene.getObjectByName('signGroup-'+group)) {\n    scene.remove(scene.getObjectByName('signGroup-'+group))\n  }\n  var coneCore = new THREE.Mesh( coneGeometry, color )\n  var shadowCone = new THREE.Mesh( coneGeometry, shadows )\n  shadowCone.scale.set(1.05, 1.05, 1.05)\n\t//coneCore.receiveShadow = true\n\tconeCore.castShadow = true\n\tvar cone = new THREE.Group()\n  var newStripe = stripe.clone()\n\tcone.add(coneCore)\n\tcone.add(newStripe)\n  var initialX\n  var coneGroup = new THREE.Group()\n  var shadowGroup = new THREE.Group()\n\n/* Buffer */\n\n  switch(group) {\n    case 1:\n      initialX = 0\n      break\n    case 2:\n      initialX = -.5\n      break\n    case 3:\n      initialX = -1.5\n      break\n    case 4:\n      initialX = -2\n      break\n    case 5:\n      initialX = -2.5\n      break\n    case 6:\n      initialX = -3\n      break\n    default:\n      break\n  }\n  var buffer = Number(document.getElementById('buffer-'+group).value)\n\tcone.position.set(initialX, .75, .5)\n\tconeGroup.add(cone)\n\tshadowCone.position.set(initialX, .75, .5)\n\tshadowGroup.add(shadowCone)\n  var x = initialX\n  var cones = 1+(buffer/100)\n  var spacing = (buffer/50)/cones\n\n  while ( Math.abs(x-spacing) <= (Math.abs((buffer/50))-initialX) && Math.abs(x) <= 23 ) {\n  \tvar newCone = cone.clone()\n    var newShadowCone = shadowCone.clone()\n  \tnewShadowCone.position.set(x, .75, .5)\n  \tshadowGroup.add(newShadowCone)\n    x -= spacing\n  \tnewCone.position.set(x, .75, .5)\n  \tconeGroup.add(newCone)\n  }\n\n/* Transition Taper */\n\n  var upstream = Number(document.getElementById('upstream-'+group).value)\n  var cones = 2+(upstream/100)\n  var spacing = (upstream/50)/cones\n  var length = (buffer/50) + (upstream/50)\n  var y = (3/cones)+.5\n  for (var i=1; i <= cones; i++) {\n    var newCone = cone.clone()\n    x -= spacing\n  \tnewCone.position.set(x, .75, y)\n    var newShadowCone = shadowCone.clone()\n  \tnewShadowCone.position.set(x, .75, y)\n  \tshadowGroup.add(newShadowCone)\n    y+=3/cones\n  \tconeGroup.add(newCone)\n  }\n\n/* Sign Spacing */\nsignSpace(color, group, x)\n\n/* Downstream Taper */\n\n  switch(group) {\n    case 1:\n      initialX = 10\n      break\n    case 2:\n      initialX = 10.5\n      break\n    case 3:\n      initialX = 11\n      break\n    case 4:\n      initialX = 11.5\n      break\n    case 5:\n      initialX = 12\n      break\n    case 6:\n      initialX = 12.5\n      break\n    default:\n      break\n  }\n  var downstream = Number(document.getElementById('downstream-'+group).value)\n  var x = initialX\n  var cones = 2+(downstream/100)\n  var spacing = (downstream/50)/cones\n  var y = .5\n  while ( Math.abs(x) <= ((downstream/50)+initialX) && Math.abs(x) <= 21.5 ) {\n  \tvar newCone = cone.clone()\n  \tnewCone.position.set(x, .75, y)\n    var newShadowCone = shadowCone.clone()\n  \tnewShadowCone.position.set(x, .75, y)\n  \tshadowGroup.add(newShadowCone)\n    y+=3/cones\n    x += spacing\n  \tconeGroup.add(newCone)\n  }\n\n/* Give Group A Name and Add To Scene */\n  coneGroup.name = group\n  shadowGroup.name = group\n  scene.add(coneGroup)\n  scene.add(shadowGroup)\n\n\n/* Close Sidebar */\n  slide('group-'+group)\n  flagger(color)\n\n  /* ------ */\n\n}\n"]}